module;
#include <algorithm>
#include <base/Assert.hh>
#include <base/Macros.hh>
#include <functional>
#include <limits>
#include <memory>
#include <numeric>
#include <ranges>
#include <SDL3/SDL.h>
export module pr.client.ui;

import base.text;
import pr.cards;
import pr.utils;
import pr.client.render;
import pr.client.render.gl;

export namespace pr::client {
struct Position;
class Element;
class Button;
class Screen;
class TextEdit;
class InputSystem;
class Label;
class Throbber;
class Image;
class Card;
class Widget;
class CardGroup;

template <typename WidgetType = Widget>
class Group;

enum class Anchor : u8;

void InitialiseUI(Renderer& r);
} // namespace pr::client

namespace pr::client {
/// Intermediate widget that consists of a box that wraps some text.
class TextBox;

/// Container for widgets.
template <typename WidgetType = Widget>
class WidgetHolder;
}

/// An anchor point for positioning elements.
enum class pr::client::Anchor : base::u8 {
    North,
    NorthEast,
    East,
    SouthEast,
    South,
    SouthWest,
    West,
    NorthWest,
    Center,
    Default = SouthWest,
};

/// A position of an element, which may be absolute or relative
/// to its parent element.
struct pr::client::Position {
    static constexpr i32 Centered = std::numeric_limits<i32>::min();

    /// Base position.
    xy base;

    /// Separate adjustment fields since the position may be centered,
    /// in which case adjustments can only be applied when the position
    /// is computed. These are always relative to the base position.
    i16 xadjust{};
    i16 yadjust{};

    /// Anchor of the position.
    Anchor anchor = Anchor::Default;

    constexpr Position() = default;
    constexpr Position(xy base, Anchor a = Anchor::Default) : base(base), anchor(a) {}
    constexpr Position(i32 x, i32 y, Anchor a = Anchor::Default) : base(x, y), anchor(a) {}

    /// Create a position that is centered horizontally or vertically.
    static constexpr auto HCenter(i32 y, Anchor a = Anchor::Default) -> Position { return {Centered, y, a}; }
    static constexpr auto VCenter(i32 x, Anchor a = Anchor::Default) -> Position { return {x, Centered, a}; }
    static constexpr auto Center(Anchor a = Anchor::Default) -> Position { return {Centered, Centered, a}; }

    /// Create a position from another position, but center it.
    static constexpr auto Center(Position pos) -> Position { return HCenter(VCenter(pos)); }
    static constexpr auto HCenter(Position pos) -> Position { return pos.base.x = Centered, pos; }
    static constexpr auto VCenter(Position pos) -> Position { return pos.base.y = Centered, pos; }

    /// Convert to an absolute position.
    auto absolute(Size screen_size, Size object_size) -> xy;

    /// Anchor the position.
    constexpr auto anchor_to(Anchor a) -> Position& {
        anchor = a;
        return *this;
    }

    /// Offset horizontally.
    constexpr auto hoffset(i32 offset) -> Position& {
        xadjust += std::saturate_cast<i16>(offset);
        return *this;
    }

    /// Convert to a relative position.
    auto relative(AABB parent_box, Size object_size) -> xy;
    auto relative(xy origin, Size parent_size, Size object_size) -> xy;

    /// Offset vertically.
    constexpr auto voffset(i32 offset) -> Position& {
        yadjust += std::saturate_cast<i16>(offset);
        return *this;
    }
};

/// User input handler.
class pr::client::InputSystem {
    struct MouseState {
        xy pos{};
        bool left{};
        bool right{};
        bool middle{};
    };

    struct Event {
        SDL_Keycode key;
        SDL_Keymod mod;
    };

    bool was_selected = false;

public:
    Renderer& renderer;
    std::u32string text_input;
    std::vector<Event> kb_events;
    MouseState mouse;
    bool quit = false;

    InputSystem(Renderer& r) : renderer(r) {}

    void game_loop(std::function<void()> tick);
    void process_events();
    void update_selection(bool is_element_selected);
};

/// The root of the UI element hierarchy.
class pr::client::Element {
    Readonly(AABB, bounding_box);

protected:
    Element() = default;
    void SetBoundingBox(AABB aabb) { _bounding_box = aabb; }
    void SetBoundingBox(xy origin, Size size) { _bounding_box = {origin, size}; }
    void UpdateBoundingBox(xy origin) { _bounding_box = {origin, _bounding_box.size()}; }
    void UpdateBoundingBox(Size size) { _bounding_box = {_bounding_box.origin(), size}; }

public:
    virtual ~Element() = default;

    /// Draw this element.
    virtual void draw(Renderer& r) = 0;
};

/// Element that is not a screen.
class pr::client::Widget : public Element {
    Readonly(Element*, parent);

public:
    bool hovered       : 1 = false; ///< Element is being hovered.
    bool hoverable     : 1 = true;  ///< Element can be hovered over.
    bool selectable    : 1 = false; ///< Element can be selected.
    bool selected      : 1 = false; ///< Element is selected.
    bool visible       : 1 = true;  ///< Element is rendered, ticked, and interactable.
    bool needs_refresh : 1 = false; ///< Element requested a refresh.

    /// Position of the widget.
    Position pos;

protected:
    explicit Widget(Element* parent, Position pos = {})
        : _parent(parent), pos(pos) {
        Assert(parent, "Every widget must have a parent!");
    }

public:
    /// Unselect the element
    void unselect();

    /// Event handler for when the mouse is clicked on this element.
    virtual void event_click(InputSystem&) {}

    /// Event handler for when a selected element is given text input.
    virtual void event_input(InputSystem&) {}

    /// Determine which of our children is being hovered, if any. Widgets
    /// that don’t have children can just return themselves.
    virtual auto hovered_child(InputSystem&) -> Widget* {
        if (not hoverable) return nullptr;
        hovered = true;
        return this;
    }

    /// Get the widget’s parent screen
    auto parent_screen() -> Screen&;

    /// Recompute bounding box etc.
    virtual void refresh(Renderer&) {}

    /// Reset properties at the start of a tick.
    void reset_properties() {
        hovered = false;
        selected = false;
    }

    /// Calculate bounding box relative to the parent.
    auto rbox() -> AABB { return {rpos(), bounding_box.size()}; }

    /// Calculate position relative to the parent using our size.
    auto rpos() -> xy {
        return pos.relative(parent->bounding_box, bounding_box.size());
    }
};

template <typename WidgetType>
class pr::client::WidgetHolder {
public:
    /// List of children.
    std::vector<std::unique_ptr<WidgetType>> children;

    /// Create an element with this as its parent.
    template <std::derived_from<WidgetType> El, typename... Args>
    auto Create(this auto& self, Args&&... args) -> El& {
        auto el = std::make_unique<El>(std::addressof(self), std::forward<Args>(args)...);
        auto& ref = *el;
        self.children.push_back(std::move(el));
        return ref;
    }
};

/// A screen that displays elements and controls user
/// interaction. A screen is an element mainly so we
/// can set it as the parent of an element.
class pr::client::Screen : public Element
    , public WidgetHolder<> {
    LIBBASE_IMMOVABLE(Screen);

    /// Previous size so we don’t refresh every frame.
    Size prev_size = {};

protected:
    /// The selected element.
    Widget* selected_element = nullptr;

    /// The hovered element.
    Widget* hovered_element = nullptr;

    /// Delete all children of this screen.
    void DeleteAllChildren();

public:
    Screen() = default;

    /// Code to run to reset a screen when it is entered.
    virtual void on_entered() {}

    /// Core to run when this screen is refreshed, before refreshing
    /// any child widgets.
    virtual void on_refresh(Renderer&) {}

    /// Render this screen.
    ///
    /// The default renderer renders all UI elements that are part of
    /// this screen.
    void draw(Renderer& r) override;

    /// Refresh all element positions.
    ///
    /// This recomputes the position of each element after the screen
    /// has been resized and before ticking/rendering.
    void refresh(Renderer& r);

    /// Tick this screen.
    ///
    /// The default tick handler visits all elements and performs UI
    /// interactions on them; thus, calling this handler is recommended
    /// if you override it.
    virtual void tick(InputSystem& input);

    /// Get all visible elements.
    auto visible() {
        return children | vws::filter([](auto& e) { return e->visible; });
    }

    friend void Widget::unselect();
};

/// Label that supports reflowing text automatically.
class pr::client::Label : public Widget {
    Text text;

    /// Whether the text should reflow onto multiple lines if it
    /// exceeds a maximum width.
    Property(bool, reflow, false);

    /// The maximum width of this text.
    Property(i32, max_width, std::numeric_limits<i32>::max());

    /// If set, the text will be centered vertically at the baseline
    /// within this height.
    Property(i32, fixed_height, 0);

    /// Whether the text is empty.
    ComputedReadonly(bool, empty, text.empty());

    /// The font size of the text.
    ComputedProperty(FontSize, font_size, text.font_size);

    /// The alignment of the text.
    ComputedProperty(TextAlign, align, text.align);

public:
    /// The colour of the label.
    Colour colour = Colour::White;

    explicit Label(Element* parent, Position pos) : Widget(parent, pos) {}
    explicit Label(Element* parent, ShapedText text, Position pos)
        : Widget(parent, pos), text(std::move(text)) {}

    explicit Label(
        Element* parent,
        Position pos,
        FontSize sz,
        TextStyle style,
        TextAlign align,
        bool reflow = true
    ) : Widget(parent, pos),
        text("", sz, align, style),
        _reflow(reflow) {}

    explicit Label(
        Element* parent,
        std::string text,
        Position pos,
        FontSize sz = FontSize::Text,
        TextStyle style = TextStyle::Regular,
        TextAlign align = TextAlign::SingleLine,
        bool reflow = true
    ) : Label(parent, pos, sz, style, align, reflow) {
        update_text(std::move(text));
    }

    void draw(Renderer& r) override;
    void refresh(Renderer& r) override;
    auto shaped(Renderer& r) -> const ShapedText& { return text.shaped(r); }
    auto size(Renderer& r) -> Size {
        if (needs_refresh) {
            refresh(r);
            needs_refresh = false;
        }

        return text.size(r);
    }

    void update_text(std::string new_text) {
        text.set(std::move(new_text));
        needs_refresh = true;
    }
};

class pr::client::TextBox : public Widget {
protected:
    ShapedText label;
    ShapedText placeholder;
    i32 padding{};
    i32 min_wd{};
    i32 min_ht{};
    i32 cursor_offs = -1; // Cursor offset from the start of the text; -1 to disable.

    explicit TextBox(
        Element* parent,
        ShapedText label,
        ShapedText placeholder,
        Position pos,
        i32 padding,
        i32 min_wd = 0,
        i32 min_ht = 0
    );

    void UpdateText(ShapedText new_text);
    auto TextPos(Renderer& r, const ShapedText& text) -> xy;

public:
    void draw(Renderer& r) override;
    void refresh(Renderer& r) override;
};

class pr::client::Button : public TextBox {
public:
    std::function<void()> on_click{};

    explicit Button(
        Element* parent,
        ShapedText label,
        Position pos,
        i32 padding = 0,
        i32 min_wd = 125,
        i32 min_ht = 0
    ) : TextBox(parent, std::move(label), ShapedText(), pos, padding, min_wd, min_ht) {}

    void event_click(InputSystem&) override {
        if (on_click) on_click();
    }

    void draw(Renderer& r) override;
};

class pr::client::TextEdit : public TextBox {
    struct Selection {
        i32 start;
        i32 end;
    };

    std::vector<ShapedText::Cluster> clusters;
    FontSize size;
    TextStyle style;
    bool dirty = false;
    bool hide_text = false;
    i32 cursor = 0;
    u32 no_blink_ticks = 0; // Used to inhibit blinking during typing.
    Selection sel{};

public:
    std::u32string text;
    TextEdit(
        Element* parent,
        Position pos,
        ShapedText placeholder,
        FontSize size = FontSize::Medium,
        TextStyle style = TextStyle::Regular,
        i32 padding = 0,
        bool hide_text = false,
        i32 min_wd = 250,
        i32 min_ht = 0
    ) : TextBox(parent, ShapedText(), std::move(placeholder), pos, padding, min_wd, min_ht),
        size{size},
        style{style},
        hide_text{hide_text} {
        selectable = true;
    }

    void draw(Renderer& r) override;
    void event_click(InputSystem& input) override;
    void event_input(InputSystem& input) override;
    void set_hide_text(bool hide) {
        hide_text = hide;
        dirty = true;
    }

    auto value() -> std::string { return text::ToUTF8(text); }
    void value(std::u32string new_text) {
        text = std::move(new_text);
        dirty = true;
    }
};

class pr::client::Throbber : public Widget {
    static constexpr f32 R = 20; // Radius of the throbber.

    VertexArrays vao;

public:
    Throbber(Element* parent, Position pos);

    void draw(Renderer& r) override;
};

class pr::client::Image : public Widget {
    Property(DrawableTexture*, texture, nullptr);

    /// The size of the image. If x or y is 0, they are set from the texture.
    Property(Size, fixed_size, {});

public:
    Image(Element* parent, Position pos) : Widget(parent, pos) {}

    void draw(Renderer& r) override;

private:
    void UpdateDimensions();
};

class pr::client::Card : public Widget {
public:
    enum Scale : u8 {
        OtherPlayer,
        Field,
        Hand,
        Preview,
        NumScales
    };

    enum struct DisplayState : u8 {
        /// Used for most cards.
        Default,

        /// A card that can not be interacted with, e.g. because it’s not
        /// our turn, because there are no valid targets, or because it has
        /// no valid targets.
        Inactive,
    };

    static constexpr Size CardSize[NumScales] = {Size{70, 100}, Size{140, 200}, Size{280, 400}, Size{420, 600}};
    static constexpr u16 Padding[NumScales] = {1, 2, 4, 6};

    // The border is slightly uneven; this is because of an optical illusion
    // that makes vertical lines appear thinner than horizontal lines, so we
    // compensate for that here, by making the X border wider than the Y border.
    static constexpr Size Border[NumScales] = {{5, 4}, {9, 8}, {17, 16}, {25, 24}};

private:
    static constexpr FontSize CodeSizes[NumScales] = {FontSize::Text, FontSize::Medium, FontSize::Huge, FontSize::Title};
    static constexpr FontSize NameSizes[NumScales] = {FontSize::Small, FontSize::Text, FontSize::Medium, FontSize::Large};
    static constexpr FontSize SoundDescriptionSizes[NumScales] = {FontSize::Text, FontSize::Medium, FontSize::Large, FontSize::Huge};
    static constexpr FontSize PowerDescriptionSizes[NumScales] = {FontSize::Small, FontSize::Text, FontSize::Intermediate, FontSize::Medium};
    static constexpr FontSize MiddleSizes[NumScales] = {FontSize::Medium, FontSize::Huge, FontSize::Title, FontSize::Gargantuan};
    static constexpr i32 BorderRadius[NumScales] = {5, 10, 20, 30};

    Property(CardId, id, CardId::$$Count);
    Property(Scale, scale, Field);
    u8 count{};
    bool needs_full_refresh = true; // Set initially so we recalculate everything.
    Label code;
    Label name;
    Label middle;
    Label description;
    Colour outline_colour;
    Image image;

public:
    DisplayState display_state = DisplayState::Default;

    Card(Element* parent, Position pos);

    void draw(Renderer& r) override;
    void refresh(Renderer&) override;
};

template <typename WidgetType>
class pr::client::Group : public Widget
    , public WidgetHolder<WidgetType> {
    /// The maximum gap size; 0 means no gap; set to a large value
    /// (e.g. INT_MAX) to use equal gaps.
    Property(i32, max_gap, 10);

    /// Write-only property to make the group selectable.
    Writeonly(bool, selectable);

public:
    Group(Element* parent, Position pos) : Widget(parent, pos) {}

    void draw(Renderer& r) override;
    auto hovered_child(InputSystem&) -> Widget* override;
    void refresh(Renderer&) override;
};

class pr::client::CardGroup : public Group<Card> {
    using Scale = Card::Scale;

    /// The scale that is set for all cards in the group.
    Property(Scale, scale, Scale::Field);

    /// The maximum width of the entire group. Ignored if 0.
    Property(i32, max_width, 0);

    /// Whether the group should scale to the next available
    /// card size if possible.
    Property(bool, autoscale, false);

    /// Write-only property to set the display state.
    Writeonly(Card::DisplayState, display_state);

public:
    static constexpr i32 CardGaps[Scale::NumScales]{5, 10, 20};

    CardGroup(Element* parent, Position pos) : CardGroup(parent, pos, {}) {}
    CardGroup(Element* parent, Position pos, std::span<CardId> cards) : Group(parent, pos) {
        for (auto c : cards) add(c);
    }

    void add(CardId c);

    void refresh(Renderer&) override;
};

template <typename WidgetType>
void pr::client::Group<WidgetType>::draw(Renderer& r) {
    for (auto& c : this->children) c->draw(r);
}

template <typename WidgetType>
auto pr::client::Group<WidgetType>::hovered_child(InputSystem& input) -> Widget* {
    auto Get = [&]<typename T>(T&& range) -> Widget* {
        for (auto& c : std::forward<T>(range)) {
            if (c->bounding_box.contains(input.mouse.pos)) {
                auto child = c->hovered_child(input);
                if (child) return child;
            }
        }

        // The group itself is a proxy widget that cannot be hovered.
        return nullptr;
    };

    // If two children overlap, we pick the first in the list, unless
    // the maximum gap is negative (which means that the widgets may
    // overlap with widgets on the right being above), in which case
    // we pick the last one.
    return max_gap < 0 ? Get(this->children | vws::reverse) : Get(this->children);
}

template <typename WidgetType>
void pr::client::Group<WidgetType>::refresh(Renderer& r) {
    if (this->children.empty()) return;

    // Reset our bounding box to our parent’s before refreshing the
    // children; otherwise, nested groups can get stuck at a smaller
    // size: the child group will base its width around the parent’s
    // which in turn is based on the width of the children; what should
    // happen instead is that groups propagate the parent size downward
    // and adjust to their actual size after the children have been
    // positioned.
    SetBoundingBox(parent->bounding_box);

    // Refresh each element to make sure their sizes are up-to-date
    // and compute the total width of all elements.
    i32 total_width = 0;
    for (auto& c : this->children) {
        c->refresh(r);
        total_width += c->bounding_box.size().wd;

        // If the gap is *negative*, i.e. we’re supposed to overlap
        // elements, factor it into the calculation.
        if (max_gap < 0) total_width += max_gap;
    }

    // Compute gap size.
    auto parent_wd = parent->bounding_box.width();
    i32 gap = 0;
    if (total_width < parent_wd and this->children.size() > 1) {
        gap = std::min(
            max_gap,
            i32((parent_wd - total_width) / (this->children.size() - 1))
        );
    } else if (max_gap < 0) {
        gap = max_gap;
    }

    // Position the children.
    i32 x = 0;
    for (auto& c : this->children) {
        c->pos = Position::VCenter(x);
        x += c->bounding_box.width() + gap;
    }

    // Update our bounding box.
    auto ht = rgs::max(this->children | vws::transform([&](auto& c) { return c->bounding_box.size().ht; }));
    auto sz = Size{x - gap, ht};
    SetBoundingBox(AABB{pos.relative(parent->bounding_box, sz), sz});

    // And refresh the children again now that we know where everything is.
    for (auto& c : this->children) c->refresh(r);
}

template <typename WidgetType>
void pr::client::Group<WidgetType>::set_max_gap(i32 new_value) {
    if (new_value == _max_gap) return;
    _max_gap = new_value;
    needs_refresh = true;
}

template <typename WidgetType>
void pr::client::Group<WidgetType>::set_selectable(bool new_value) {
    for (auto& c : this->children) c->selectable = new_value;
}

template <>
struct std::formatter<pr::client::Position> : std::formatter<std::string> {
    template <typename FormatContext>
    auto format(pr::client::Position pos, FormatContext& ctx) const {
        return std::formatter<std::string>::format(
            std::format(
                "Position(base={}, xadjust={}, yadjust={}, anchor={})",
                pos.base,
                pos.xadjust,
                pos.yadjust,
                std::to_underlying(pos.anchor)
            ),
            ctx
        );
    }
};
