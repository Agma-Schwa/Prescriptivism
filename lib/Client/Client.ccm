module;
#include <base/Assert.hh>
#include <base/Macros.hh>
#include <functional>
#include <memory>
#include <pr/Packets.hh>
#include <ranges>
#include <thread>
#include <vector>
export module pr.client;

import pr.utils;
import pr.cards;
import pr.packets;
import pr.constants;
import pr.client.ui;
import pr.client.render;
import pr.client.render.gl;
import pr.tcp;

export namespace pr::client {
class Client;
}

namespace pr::client {
class MenuScreen;
class ErrorScreen;
class ConnexionScreen;
class WaitingScreen;
class WordChoiceScreen;
class GameScreen;
class Player;
} // namespace pr::client

// =============================================================================
//  General Screens
// =============================================================================
/// Main menu of the game.
class pr::client::MenuScreen : public Screen {
public:
    MenuScreen(Client& c);
};

/// Screen that displays an error.
class pr::client::ErrorScreen : public Screen {
    /// Text to display.
    Label* msg;

    /// The screen to return to after this one is closed.
    Screen* return_screen = nullptr;

public:
    ErrorScreen(Client& c);

    /// Set the text to display and the screen to return to.
    void enter(Client& c, std::string t, Screen& return_to);
};

// =============================================================================
//  Connexion Phase Screens
// =============================================================================
/// Screen that is displayed while we connect to a server.
///
/// This screen has all the connexion logic.
class pr::client::ConnexionScreen : public Screen {
    enum class State : u32 {
        Entered,    ///< The screen has just been entered.
        Connecting, ///< We are trying to connect in a separate thread.
        Aborted,    ///< The 'Cancel' button was pressed.
    };

    Client& client;
    State st;
    std::string address, username, password;
    Thread<net::TCPConnexion> connexion_thread;

public:
    ConnexionScreen(Client& c);

    void enter(std::string address, std::string username, std::string password);
    void tick(InputSystem& input) override;
    void set_address(std::string addr);

private:
    auto connexion_thread_main(std::string address, std::stop_token st) -> Result<net::TCPConnexion>;
};

class pr::client::WaitingScreen : public Screen {
public:
    WaitingScreen(Client& c);
};

class pr::client::WordChoiceScreen : public Screen {
    Client& client;
    CardStacks* cards;
    constants::Word original_word;
    CardStacks::Stack* selected = nullptr;

    void SendWord();

public:
    WordChoiceScreen(Client& c);

    // This takes an array instead of a span to force a specific word size.
    void enter(const constants::Word& word);
    void on_refresh(Renderer& r) override;
    void tick(InputSystem& input) override;
};

// =============================================================================
//  In-game Screens
// =============================================================================
class pr::client::Player {
    LIBBASE_MOVE_ONLY(Player);

    /// The server-side player id.
    Readonly(u8, id);

    /// The player name.
    Readonly(std::string, name);

public:
    /// The current word of this player.
    CardStacks* word{};

    /// Get the playerâ€™s word as a list of card ids.
    auto cards() -> std::vector<CardId> {
        return word->top_cards() | vws::transform(&Card::get_id) | rgs::to<std::vector>();
    }

    explicit Player() = default;
    explicit Player(std::string name, u8 id) : _id{id}, _name{std::move(name)} {}
};

/// This screen renders the actual game.
class pr::client::GameScreen : public Screen {
    Client& client;

    /// The other players in the game.
    std::vector<Player> other_players;

    /// Map from card groups to their players.
    std::unordered_map<CardStacks*, Player*> player_map;

    /// Our player object.
    Player us;

    /// The cards in our hand.
    CardStacks* our_hand{};

    /// The words of other players.
    Group* other_words{};

    /// The card widget used to preview a card.
    Card* preview{};

    /// True if it is our turn
    bool our_turn{false};

    /// The last card that was selected by the player
    Card* our_selected_card{};

public:
    explicit GameScreen(Client& c);
    void add_card(PlayerId id, u32 stack_idx, CardId card);
    void add_card_to_hand(CardId id);
    void enter(packets::sc::StartGame sg);
    void end_turn();
    void on_refresh(Renderer& r) override;
    void start_turn();
    void tick(InputSystem& input) override;

private:
    auto PlayerById(PlayerId id) -> Player&;
    auto PlayerForCardInWord(Card* c) -> Player*; /// Return the player that owns this card in their word.
    void ResetOpponentWords();
    void TickSelection();
};

// =============================================================================
//  Client
// =============================================================================
class pr::client::Client {
    LIBBASE_IMMOVABLE(Client);

public:
    /// The main renderer.
    Renderer renderer;

    /// The user input handler.
    InputSystem input_system{renderer};

    /// Screens.
    MenuScreen menu_screen{*this};
    ConnexionScreen connexion_screen{*this};
    ErrorScreen error_screen{*this};
    WaitingScreen waiting_screen{*this};
    WordChoiceScreen word_choice_screen{*this};
    GameScreen game_screen{*this};

    /// Connexion to the game server.
    net::TCPConnexion server_connexion;

private:
    Screen* current_screen = nullptr;

    explicit Client(Renderer r);

public:
    /// Run the client for ever.
    static void Run();

    /// Run the client for ever, and immediately connect to a server.
    static void RunAndConnect(
        std::string address,
        std::string username,
        std::string password
    );

    /// Enter a screen.
    void enter_screen(Screen& s);

    /// Show an error to the user.
    void show_error(std::string error, Screen& return_to);

#define X(name) void handle(packets::sc::name);
    COMMON_PACKETS(X)
    SC_PACKETS(X)
#undef X

private:
    static auto Startup() -> Renderer;

    void RunGame();
    void Tick();
    void TickNetworking();
};
