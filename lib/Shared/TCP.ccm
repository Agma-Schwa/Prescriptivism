module;
#include <base/Macros.hh>
#include <bit>
#include <cstring>
#include <functional>
#include <memory>
#include <optional>
#include <span>
#include <type_traits>
#include <vector>
export module pr.tcp;
import pr.utils;

export namespace pr::net {
class TCPServerCallbacks;
class TCPServer;
class TCPConnexion;
class ReceiveBuffer;
class SendBuffer;

constexpr u16 DefaultPort = 33'014;
} // namespace pr::net

/// Buffer for receiving data from a TCP connexion.
class pr::net::ReceiveBuffer {
    LIBBASE_IMMOVABLE(ReceiveBuffer);

public:
    /// Helper class to (partially) deserialise objects.
    class Reader {
        std::span<std::byte> data;
        bool ok;

    public:
        explicit Reader(std::span<std::byte> data) : data(data), ok(true) {}

        /// Read several fields from this packet.
        void operator()(auto&... fields) {
            (void) ((*this >> fields, ok) and ...);
        }

        /// Read a number from this packet.
        template <std::integral T>
        T read() {
            T t;
            *this >> t;
            return t;
        }

        template <std::integral T>
        auto operator>>(T& t) -> Reader& {
            Copy(&t, sizeof(T));
            if constexpr (std::endian::native != std::endian::little) t = std::byteswap(t);
            return *this;
        }

        template <typename T>
        requires std::is_enum_v<T>
        auto operator>>(T& t) -> Reader& {
            std::underlying_type_t<T> u;
            *this >> u;
            t = static_cast<T>(u);
            return *this;
        }

        /// Read a string from this packet.
        auto operator>>(std::string& s) -> Reader& {
            s.resize_and_overwrite(
                read<usz>(),
                [&](char* ptr, usz count) { return Copy(ptr, count); }
            );
            return *this;
        }

        /// Check if we could read the entire thing.
        [[nodiscard]] explicit operator bool() { return ok; }

        /// Check how many bytes are left in the buffer.
        [[nodiscard]] auto size() const -> usz { return data.size(); }

    private:
        usz Copy(void* ptr, usz count) {
            if (data.size() < count or not ok) {
                ok = false;
                return 0;
            }

            std::memcpy(ptr, data.data(), count);
            data = data.subspan(count);
            return count;
        }
    };

private:
    std::span<std::byte> data;

public:
    ReceiveBuffer(std::vector<std::byte>& buffer) : data(buffer) {}

    /// Check if the buffer is empty.
    [[nodiscard]] auto empty() const -> bool { return data.empty(); }

    /// \see read().
    [[nodiscard]] auto peek(usz n) -> std::span<std::byte> {
        if (n > data.size()) return {};
        return data.subspan(0, n);
    }

    /// \see read().
    template <typename T>
    requires std::is_trivially_copyable_v<T> and std::is_default_constructible_v<T>
    auto peek() -> std::optional<T> {
        if (data.size() < sizeof(T)) return std::nullopt;
        auto n = peek(sizeof(T));
        T result;
        std::memcpy(&result, n.data(), sizeof(T));
        return result;
    }

    /// Read data from the buffer and discard it.
    ///
    /// If there are fewer bytes in the buffer than requested,
    /// nothing is read and the remains unchanged. Otherwise,
    /// \p n bytes are removed from the start of the buffer and
    /// returned.
    ///
    /// \param n The number of bytes to read.
    [[nodiscard]] auto read(usz n) -> std::span<std::byte> {
        if (n > data.size()) return {};
        auto result = data.subspan(0, n);
        data = data.subspan(n);
        return result;
    }

    /// As read(), but attempts to read a value of a specific type
    /// instead, returning an empty optional if there are not enough
    /// bytes in the buffer.
    template <typename T>
    [[nodiscard]] auto read() -> std::optional<T> {
        static_assert(
            requires (T t, Reader r) { t.deserialise(r); },
            "Type must implement deserialise()"
        );

        T res;
        Reader reader{data};
        res.deserialise(reader);
        if (not reader) return std::nullopt;
        data = data.subspan(data.size() - reader.size());
        return res;
    }

    /// How many bytes are in the buffer.
    [[nodiscard]] auto size() const -> usz { return data.size(); }
};

/// Helper for serialising data into a buffer.
class pr::net::SendBuffer {
    std::vector<std::byte> data;

    friend TCPConnexion;

public:
    /// Write several fields to this packet.
    void operator()(auto&... fields) {
        (*this << ... << fields);
    }

    /// Write a type to this packet.
    template <typename T>
    auto operator<<(const T& t) -> SendBuffer& {
        write(t);
        return *this;
    }

    /// Write a type to this packet.
    template <std::integral T>
    void write(T t) {
        if constexpr (std::endian::native != std::endian::little) t = std::byteswap(t);
        Append(&t, sizeof(T));
    }

    template <typename T>
    requires std::is_enum_v<T>
    void write(T t) {
        write(std::to_underlying(t));
    }

    /// Write a string to this packet.
    void write(const std::string& s) {
        write(s.size());
        Append(s.data(), s.size());
    }

private:
    void Append(const void* ptr, usz count) {
        auto* p = static_cast<const std::byte*>(ptr);
        data.insert(data.end(), p, p + count);
    }
};

/// Class that implements common functionality for TCP server
/// that must be implemented by users.
class pr::net::TCPServerCallbacks {
    LIBBASE_IMMOVABLE(TCPServerCallbacks);

protected:
    TCPServerCallbacks() = default;

public:
    virtual ~TCPServerCallbacks() = default;

    /// Called to query if we should accept a connexion. If this returns
    /// false, the connexion is closed. The implementation of this is free
    /// to send data to the client before returning.
    virtual bool accept(TCPConnexion& connexion) = 0;

    /// Called from TCPServer::receive().
    ///
    /// \param connexion The connexion that sent the data.
    /// \param data A buffer that contains any unprocessed data since
    /// the last call to receive(). The buffer should be updated to
    /// remove any data that has been processed.
    virtual void receive(TCPConnexion& connexion, ReceiveBuffer& data) = 0;
};

/// A reference type that holds a TCP connexion that can be
/// used to communicate with a remote peer. This can be a
/// connexion to a server or to a client.
///
/// The actual state is managed by a shared pointer, so copying
/// this and storing copies of it is safe.
class pr::net::TCPConnexion {
    friend TCPServer; // Server needs to create client connexions.

    struct Impl;
    std::shared_ptr<Impl> impl;

public:
    TCPConnexion();
    ~TCPConnexion();

    /// Connect to a server.
    static auto Connect(std::string_view remote_address, u16 port) -> Result<TCPConnexion>;

    /// Get the ip address of the remote peer.
    auto address() const -> std::string_view;

    /// Close the connexion.
    void disconnect();

    /// Check if the connexion has been disconnected.
    bool disconnected() const;

    /// Receive data from the remote peer.
    void receive(std::function<void(ReceiveBuffer&)> callback);

    /// Send data to the remote peer.
    template <typename T>
    void send(const T& t) {
        // Type requires serialisation.
        if constexpr (requires (T t, SendBuffer s) { t.serialise(s); }) {
            SendBuffer buffer;
            t.serialise(buffer);
            send(std::span<const std::byte>{buffer.data});
        }

        // Type can be sent as-is.
        else {
            static_assert(
                std::is_trivially_copyable_v<T>,
                "Type must be trivially copyable or implement serialise()"
            );

            send(std::span{reinterpret_cast<const std::byte*>(&t), sizeof(T)});
        }
    }

    /// Send data to the remote peer.
    void send(std::span<const std::byte> data);
};

/// A reference type that holds a TCP server that can accept
/// incoming connexions.
class pr::net::TCPServer {
    LIBBASE_DECLARE_HIDDEN_IMPL(TCPServer);

public:
    /// Create a server socket that listens on the given port.
    static auto Create(u16 port, u32 max_connexions) -> Result<TCPServer>;

    /// Get the connexions that we have accepted.
    auto connexions() -> std::span<TCPConnexion>;

    /// Receive data from existing connexions. Calls
    /// TCPEventHandler::Receive() with the data.
    void receive();

    /// Get the server port.
    auto port() const -> u16;

    /// Set the server callback handler.
    void set_callbacks(TCPServerCallbacks& callbacks);

    /// Accept incoming connexions and throw away any that have
    /// gone stale. If there is an error with a connexion, it
    /// is logged and the connexion is thrown away.
    ///
    /// Any references to connexions that have been closed must
    /// be cleaned up before this is called, as this deletes any
    /// closed connexions.
    void update_connexions();
};
