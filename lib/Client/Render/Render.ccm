module;
#include <base/Macros.hh>
#include <freetype/freetype.h>
#include <glm/glm.hpp>
#include <hb.h>
#include <memory>
#include <SDL3/SDL_mouse.h>
#include <SDL3/SDL_video.h>
#include <unordered_map>
#include <vector>
export module pr.client.render;

import pr.utils;
import base.text;
import pr.client.render.gl;

export namespace pr::client {
struct Colour;
struct Size;
struct AABB;
struct xy;

class Renderer;
class Font;
class ShapedText;
class Text;

enum struct FontSize : u32;
enum struct TextAlign : u8;
enum struct Cursor : u32;
} // namespace pr::client

// =============================================================================
//  Utility Types
// =============================================================================
/// To keep font sizes uniform.
enum struct pr::client::FontSize : base::u32 {
    Small = 6,
    Text = 12,
    Medium = 24,
    Large = 36,
    Huge = 48,
    Title = 96,
};

/// Alignment of shaped text.
///
/// This is only relevant for multiline text; for single-line text,
/// you can specify SingleLine to indicate that.
enum struct pr::client::TextAlign : base::u8 {
    Left,
    Center,
    Right,
    SingleLine = Left,
};

enum struct pr::client::Cursor : base::u32 {
    Default = SDL_SYSTEM_CURSOR_DEFAULT,
    IBeam = SDL_SYSTEM_CURSOR_TEXT,
};

struct pr::client::Colour {
    u8 r;
    u8 g;
    u8 b;
    u8 a;

    /// Create a new colour.
    constexpr Colour(u8 r, u8 g, u8 b, u8 a = 255) : r(r), g(g), b(b), a(a) {}
    constexpr static auto ABGR(u32 abgr) -> Colour {
        if constexpr (std::endian::native == std::endian::big)
            abgr = std::byteswap(abgr);

        return {
            u8(abgr & 0xFF),
            u8(abgr >> 8 & 0xFF),
            u8(abgr >> 16 & 0xFF),
            u8(abgr >> 24 & 0xFF),
        };
    }

    constexpr f32 red() const { return r / 255.0f; }
    constexpr f32 green() const { return g / 255.0f; }
    constexpr f32 blue() const { return b / 255.0f; }
    constexpr f32 alpha() const { return a / 255.0f; }
    constexpr auto vec4() const -> glm::vec4 { return {red(), green(), blue(), alpha()}; }

    static constinit const Colour White;
    static constinit const Colour Black;
    static constinit const Colour Grey;
};

constexpr pr::client::Colour pr::client::Colour::White = {255, 255, 255, 255};
constexpr pr::client::Colour pr::client::Colour::Black = {0, 0, 0, 255};
constexpr pr::client::Colour pr::client::Colour::Grey = {128, 128, 128, 255};

struct pr::client::Size {
    i32 wd{};
    i32 ht{};

    constexpr Size() = default;
    constexpr Size(i32 wd, i32 ht) : wd(wd), ht(ht) {}

private:
    friend constexpr bool operator==(Size, Size) = default;
};

// XY position that is destructurable.
struct pr::client::xy {
    i32 x{};
    i32 y{};

    constexpr xy() = default;
    constexpr xy(i32 x, i32 y) : x(x), y(y) {}
    constexpr xy(vec2 v) : x(i32(v.x)), y(i32(v.y)) {}
    constexpr xy(f32 x, f32 y) : x(i32(x)), y(i32(y)) {}
    constexpr xy(f64 x, f64 y) : x(i32(x)), y(i32(y)) {}
    constexpr xy(Size sz) : x(sz.wd), y(sz.ht) {}

    constexpr auto vec() const -> vec2 { return {f32(x), f32(y)}; }

private:
    friend constexpr bool operator==(xy, xy) = default;
    friend constexpr xy operator+(xy a, xy b) { return {a.x + b.x, a.y + b.y}; }
    friend constexpr xy operator-(xy a, xy b) { return {a.x - b.x, a.y - b.y}; }
};

/// Axis-aligned bounding box.
struct pr::client::AABB {
    xy min;
    xy max;

    constexpr AABB() = default;
    constexpr AABB(i32 x, i32 y, i32 wd, i32 ht) : min(x, y), max(x + wd, y + ht) {}
    constexpr AABB(xy min, xy max) : min(min), max(max) {}
    constexpr AABB(xy pos, Size sz) : min(pos), max(pos.x + sz.wd, pos.y + sz.ht) {}

    /// Check if this box contains a point.
    auto contains(xy) const -> bool;

    /// Get the height of this box.
    constexpr auto height() const -> i32 { return max.y - min.y; }

    /// Get the width of this box.
    constexpr auto width() const -> i32 { return max.x - min.x; }
};

// =============================================================================
//  Text
// =============================================================================
/// Text to be rendered.
class pr::client::ShapedText {
    friend Renderer;
    friend Font;

public:
    struct Cluster {
        i32 index; ///< Cluster index.
        i32 xoffs; ///< X position right before the cluster.

        bool operator<(const Cluster& rhs) const { return index < rhs.index; }
        bool operator==(const Cluster& rhs) const { return index == rhs.index; }
    };

private:
    VertexArrays vao;
    u32 fsize;
    f32 wd;
    f32 ht;
    f32 dp;

    explicit ShapedText(VertexArrays vao, u32 fsize, f32 wd, f32 ht, f32 dp)
        : vao(std::move(vao)), fsize(fsize), wd(wd), ht(ht), dp(dp) {}

public:
    /// Create an empty text object that optionally stores a font size.
    explicit ShapedText(FontSize sz = FontSize::Text)
        : vao{VertexLayout::PositionTexture4D},
          fsize{+sz},
          wd{},
          ht{},
          dp{} {}

    /// Debugging function that dumps the contents of a HarfBuzz buffer;
    /// must be called after shaping.
    static auto DumpHBBuffer(hb_font_t* font, hb_buffer_t* buf);

    /// Get the depth of the text.
    auto depth() const -> f32 { return dp; }

    /// Check if this text is empty.
    auto empty() const -> bool { return vao.empty(); }

    /// Get the font size.
    auto font_size() const -> FontSize { return FontSize(fsize); }

    /// Get the height of the text.
    auto height() const -> f32 { return ht; }

    /// Get the size of the text, including depth.
    auto size() const -> Size { return {i32(wd), i32(ht + dp)}; }

    /// Get the vertices for this text.
    auto verts() const -> const VertexArrays& { return vao; }

    /// Get the width of the text.
    auto width() const -> f32 { return wd; }
};

/// Text to be rendered that also stores the characters of the text.
class pr::client::Text {
    mutable ShapedText text{FontSize::Text};
    std::string content;
    TextAlign align = TextAlign::SingleLine;
    mutable bool dirty = false;

public:
    Text() {}
    Text(ShapedText t, TextAlign align = TextAlign::SingleLine) : text{std::move(t)}, align{align} {}
    Text(std::string s, FontSize sz, TextAlign align) : text{sz}, content{std::move(s)}, align{align}, dirty{true} {}
    Text(std::u32string_view s, FontSize sz, TextAlign align) : Text{base::text::ToUTF8(s), sz, align} {}

    /// Check if this text is empty.
    bool empty() const { return content.empty() and text.size() == Size{}; }

    /// Reflow the text to fit within the given width.
    void reflow(Renderer& r, i32 width);

    /// Update the text.
    void set(std::string new_text) {
        content = std::move(new_text);
        dirty = true;
    }

    /// Get this as shaped text, shaping it if it is not already shaped.
    auto shaped(Renderer& r) const -> const ShapedText&;
};

/// A fixed-sized font, combined with a HarfBuzz shaper and texture atlas.
class pr::client::Font {
    using HarfBuzzFontHandle = std::unique_ptr<hb_font_t, decltype(&hb_font_destroy)>;
    using HarfBuzzBufferHandle = std::unique_ptr<hb_buffer_t, decltype(&hb_buffer_destroy)>;
    struct Metrics {
        vec2 size;
        vec2 bearing;
    };

    /// HarfBuzz font to use for shaping.
    HarfBuzzFontHandle hb_font = {nullptr, hb_font_destroy};

    /// Cached HarfBuzz buffers to use for shaping.
    std::vector<HarfBuzzBufferHandle> hb_bufs;

    /// Metrics for all glyphs in the font.
    std::vector<Metrics> glyphs{};

    /// The width and height of a cell in the texture atlas.
    u32 atlas_entry_width{};
    u32 atlas_entry_height{};

    /// The number of columns and rows in the texture atlas.
    u32 atlas_columns{};
    u32 atlas_rows{};

    /// The font size.
    u32 size{};

    /// Interline skip.
    ///
    /// In multiline text, if the height+depth of a line is less than
    /// this value it will be padded to this height.
    u32 skip{};

    /// The atlas texture.
    Texture atlas;

public:
    Font() = default;
    Font(FT_Face ft_face, u32 size, u32 skip);
    Font(FT_Face ft_face, u32 size)
        : Font(ft_face, size, u32(size * 1.2)) {}

    /// Shape text using this font.
    ///
    /// The resulting object is position-independent and can
    /// be drawn at any coordinates.
    auto shape(
        std::u32string_view text,
        TextAlign align,
        std::vector<ShapedText::Cluster>* clusters = nullptr
    ) -> ShapedText;

    /// Activate the font for rendering.
    void use() const { atlas.bind(); }

    /// Get the height and width of a cell in the atlas.
    auto cell_height() const -> u32 { return atlas_entry_height; }
    auto cell_width() const -> u32 { return atlas_entry_width; }

    /// Get the number of rows and columns in the atlas.
    auto columns() const -> u32 { return atlas_columns; }
    auto rows() const -> u32 { return atlas_rows; }

    /// Get the total width and height of the atlas.
    auto height() const -> u32 { return atlas_rows * atlas_entry_height; }
    auto width() const -> u32 { return atlas_columns * atlas_entry_width; }
};

// =============================================================================
//  Renderer
// =============================================================================
/// A renderer that renders to a window.
class pr::client::Renderer {
    LIBBASE_IMMOVABLE(Renderer);

    SDL_Window* window;
    SDL_GLContextState* context;

public:
    ShaderProgram primitive_shader;
    ShaderProgram text_shader;
    ShaderProgram image_shader;
    ShaderProgram throbber_shader;

private:
    FT_Library ft;
    FT_Face ft_face;
    std::unordered_map<u32, Font> fonts_by_size;
    std::unordered_map<Cursor, SDL_Cursor*> cursor_cache;
    Cursor active_cursor = Cursor::Default;
    Cursor requested_cursor = Cursor::Default;

public:
    class Frame {
        LIBBASE_IMMOVABLE(Frame);
        Renderer& r;
        friend Renderer;
        explicit Frame(Renderer& r);
    public:
        ~Frame();
    };

    /// Create a new window and renderer.
    Renderer(int initial_wd, int initial_ht);

    /// Clean up resources.
    ~Renderer();

    /// Whether to render blinking cursors.
    ///
    /// \return True to render the cursor, false to hide it.
    bool blink_cursor();

    /// Clear the screen.
    void clear(Colour c = Colour::White);

    /// Draw a line between two points.
    void draw_line(xy start, xy end, Colour c = Colour::White);

    /// Draw a rectangle at a position in world coordinates.
    void draw_rect(xy pos, Size size, Colour c = Colour::White);

    /// Draw text at a position in world coordinates.
    void draw_text(const ShapedText& text, xy pos, Colour c = Colour::White);
    void draw_text(const Text& text, xy pos, Colour c = Colour::White);

    /// Draw a texture at a position in world coordinates.
    void draw_texture(const DrawableTexture& tex, xy pos);

    /// Start a new frame.
    auto frame() -> Frame;

    /// Create a text object that can be drawn.
    auto make_text(
        std::string_view text,
        FontSize size,
        TextAlign align = TextAlign::Left,
        std::vector<ShapedText::Cluster>* clusters = nullptr
    ) -> ShapedText;

    auto make_text(
        std::u32string_view text,
        FontSize size,
        TextAlign align = TextAlign::Left,
        std::vector<ShapedText::Cluster>* clusters = nullptr
    ) -> ShapedText;

    /// Reload all shaders.
    ///
    /// ONLY USED DURING DEVELOPMENT!!!
    void reload_shaders();

    /// Set the active cursor.
    void set_cursor(Cursor);

    /// Get the SDL window.
    auto sdl_window() -> SDL_Window* { return window; }

    /// Get the size of the window.
    auto size() -> Size;

    /// Set the active shader.
    void use(ShaderProgram& shader);

private:
    /// Get a font of a given size.
    auto font(u32 size) -> Font&;

    /// Start/end a frame.
    void frame_end();
    void frame_start();

    /// Set the current cursor.
    void set_cursor_impl();
};
