module;
#include <base/Macros.hh>
#include <cstring>
#include <functional>
#include <memory>
#include <optional>
#include <span>
#include <type_traits>
#include <vector>
export module pr.tcp;
import pr.utils;

export namespace pr::net {
class TCPServerCallbacks;
class TCPServer;
class TCPConnexion;
class ReceiveBuffer;

constexpr u16 DefaultPort = 33'014;
}

class pr::net::ReceiveBuffer {
    LIBBASE_IMMOVABLE(ReceiveBuffer);

    std::span<std::byte> data;

public:
    ReceiveBuffer(std::vector<std::byte>& buffer) : data(buffer) {}

    /// Check if the buffer is empty.
    auto empty() const -> bool { return data.empty(); }

    /// \see read().
    auto peek(usz n) -> std::span<std::byte> {
        if (n > data.size()) return {};
        return data.subspan(0, n);
    }

    /// \see read().
    template <typename T>
    requires std::is_trivially_copyable_v<T> and std::is_default_constructible_v<T>
    auto peek() -> std::optional<T> {
        if (data.size() < sizeof(T)) return std::nullopt;
        auto n = peek(sizeof(T));
        T result;
        std::memcpy(&result, n.data(), sizeof(T));
        return result;
    }

    /// Read data from the buffer and discard it.
    ///
    /// If there are fewer bytes in the buffer than requested,
    /// nothing is read and the remains unchanged. Otherwise,
    /// \p n bytes are removed from the start of the buffer and
    /// returned.
    ///
    /// \param n The number of bytes to read.
    auto read(usz n) -> std::span<std::byte> {
        if (n > data.size()) return {};
        auto result = data.subspan(0, n);
        data = data.subspan(n);
        return result;
    }

    /// As read(), but attempts to read a value of a specific type
    /// instead, returning an empty optional if there are not enough
    /// bytes in the buffer.
    template <typename T>
    requires std::is_trivially_copyable_v<T>
    auto read() -> std::optional<T> {
        if (data.size() < sizeof(T)) return std::nullopt;
        auto n = read(sizeof(T));
        T result;
        std::memcpy(&result, n.data(), sizeof(T));
        return result;
    }

    /// How many bytes are in the buffer.
    auto size() const -> usz {
        return data.size();
    }
};

/// Class that implements common functionality for TCP server
/// that must be implemented by users.
class pr::net::TCPServerCallbacks {
    LIBBASE_IMMOVABLE(TCPServerCallbacks);

protected:
    TCPServerCallbacks() = default;

public:
    virtual ~TCPServerCallbacks() = default;

    /// Called to query if we should accept a connexion. If this returns
    /// false, the connexion is closed. The implementation of this is free
    /// to send data to the client before returning.
    virtual bool accept(TCPConnexion& connexion)  = 0;

    /// Called from TCPServer::receive().
    ///
    /// \param connexion The connexion that sent the data.
    /// \param data A buffer that contains any unprocessed data since
    /// the last call to receive(). The buffer should be updated to
    /// remove any data that has been processed.
    virtual void receive(TCPConnexion& connexion, ReceiveBuffer& data) = 0;
};

/// A reference type that holds a TCP connexion that can be
/// used to communicate with a remote peer. This can be a
/// connexion to a server or to a client.
///
/// The actual state is managed by a shared pointer, so copying
/// this and storing copies of it is safe.
class pr::net::TCPConnexion {
    friend TCPServer; // Server needs to create client connexions.

    struct Impl;
    std::shared_ptr<Impl> impl;

public:
    TCPConnexion();
    ~TCPConnexion();

    /// Connect to a server.
    static auto Connect(std::string_view remote_address, u16 port) -> Result<TCPConnexion>;

    /// Get the ip address of the remote peer.
    auto address() const -> std::string_view;

    /// Close the connexion.
    void disconnect();

    /// Check if the connexion has been disconnected.
    bool disconnected() const;

    /// Receive data from the remote peer.
    void receive(std::function<void(ReceiveBuffer&)> callback);

    /// Send a struct to the remote peer.
    template <typename T>
    requires std::is_class_v<T>
    void send(const T& t) {
        send(std::span{reinterpret_cast<const std::byte*>(&t), sizeof(T)});
    }

    /// Send data to the remote peer.
    void send(std::span<const std::byte> data);
};

/// A reference type that holds a TCP server that can accept
/// incoming connexions.
class pr::net::TCPServer {
    LIBBASE_DECLARE_HIDDEN_IMPL(TCPServer);

public:
    /// Create a server socket that listens on the given port.
    static auto Create(u16 port, u32 max_connexions) -> Result<TCPServer>;

    /// Get the connexions that we have accepted.
    auto connexions() -> std::span<TCPConnexion>;

    /// Receive data from existing connexions. Calls
    /// TCPEventHandler::Receive() with the data.
    void receive();

    /// Get the server port.
    auto port() const -> u16;

    /// Set the server callback handler.
    void set_callbacks(TCPServerCallbacks& callbacks);

    /// Accept incoming connexions and throw away any that have
    /// gone stale. If there is an error with a connexion, it
    /// is logged and the connexion is thrown away.
    ///
    /// Any references to connexions that have been closed must
    /// be cleaned up before this is called, as this deletes any
    /// closed connexions.
    void update_connexions();
};
