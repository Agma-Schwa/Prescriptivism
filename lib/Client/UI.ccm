module;
#include <base/Macros.hh>
#include <functional>
#include <limits>
#include <memory>
#include <numeric>
#include <SDL3/SDL.h>
export module pr.client.ui;

import base.text;
import pr.utils;
import pr.client.render;
import pr.client.render.gl;

export namespace pr::client {
struct Position;
class Element;
class Button;
class Screen;
class TextEdit;
class InputSystem;
class Label;
class Throbber;
class Card;

enum class Anchor : u8;
} // namespace pr::client

namespace pr::client {
/// Intermediate widget that consists of a box that wraps some text.
class TextBox;
}

/// An anchor point for positioning elements.
enum class pr::client::Anchor : base::u8 {
    North,
    NorthEast,
    East,
    SouthEast,
    South,
    SouthWest,
    West,
    NorthWest,
    Center,
    Default = SouthWest,
};

/// A position of an element, which may be absolute or relative
/// to its parent element.
struct pr::client::Position {
    static constexpr i32 Centered = std::numeric_limits<i32>::min();

    /// Base position.
    xy base;

    /// Separate adjustment fields since the position may be centered,
    /// in which case adjustments can only be applied when the position
    /// is computed. These are always relative to the base position.
    i16 xadjust{};
    i16 yadjust{};

    /// Anchor of the position.
    Anchor anchor = Anchor::Default;

    constexpr Position() = default;
    constexpr Position(xy base, Anchor a = Anchor::Default) : base(base), anchor(a) {}
    constexpr Position(i32 x, i32 y, Anchor a = Anchor::Default) : base(x, y), anchor(a) {}

    /// Create a position that is centered horizontally or vertically.
    static constexpr auto HCenter(i32 y, Anchor a = Anchor::Default) -> Position { return {Centered, y, a}; }
    static constexpr auto VCenter(i32 x, Anchor a = Anchor::Default) -> Position { return {x, Centered, a}; }
    static constexpr auto Center(Anchor a = Anchor::Default) -> Position { return {Centered, Centered, a}; }

    /// Convert to an absolute position.
    auto absolute(Size screen_size, Size object_size) -> xy;

    /// Anchor the position.
    constexpr auto anchor_to(Anchor a) -> Position& {
        anchor = a;
        return *this;
    }

    /// Offset horizontally.
    constexpr auto hoffset(i32 offset) -> Position& {
        xadjust += std::saturate_cast<i16>(offset);
        return *this;
    }

    /// Convert to a relative position.
    auto relative(xy origin, Size parent_size, Size object_size) -> xy;

    /// Offset vertically.
    constexpr auto voffset(i32 offset) -> Position& {
        yadjust += std::saturate_cast<i16>(offset);
        return *this;
    }
};

/// User input handler.
class pr::client::InputSystem {
    struct MouseState {
        xy pos{};
        bool left{};
        bool right{};
        bool middle{};
    };

    struct Event {
        SDL_Keycode key;
        SDL_Keymod mod;
    };

    bool was_selected = false;

public:
    Renderer& renderer;
    std::u32string text_input;
    std::vector<Event> kb_events;
    MouseState mouse;
    bool quit = false;

    InputSystem(Renderer& r) : renderer(r) {}

    void process_events();
    void update_selection(bool is_element_selected);
};

class pr::client::Element {
    AABB box;

public:
    bool hovered    : 1 = false;
    bool selectable : 1 = false;
    bool selected   : 1 = false;

protected:
    Element() = default;
    void SetBoundingBox(AABB aabb) { box = aabb; }

public:
    virtual ~Element() = default;

    /// Get the bounding box of this element.
    auto bounding_box() const -> AABB { return box; }

    /// Event handler for when the mouse is clicked on this element.
    virtual void event_click(InputSystem&) {}

    /// Event handler for when a selected element is given text input.
    virtual void event_input(InputSystem&) {}

    /// Draw this element.
    virtual void draw(Renderer& r) = 0;

    /// Recompute bounding box etc.
    virtual void refresh(Size) {}

    /// Reset properties at the start of a tick.
    void reset_properties() {
        hovered = false;
        selected = false;
    }
};

class pr::client::Screen {
    LIBBASE_IMMOVABLE(Screen);

    /// List of children.
    std::vector<std::unique_ptr<Element>> children;

    /// The selected element.
    Element* selected = nullptr;

protected:
    Screen() = default;

public:
    virtual ~Screen() = default;

    /// Create an element.
    template <std::derived_from<Element> El, typename... Args>
    auto Create(Args&&... args) -> El& {
        auto el = std::make_unique<El>(std::forward<Args>(args)...);
        auto& ref = *el;
        children.push_back(std::move(el));
        return ref;
    }

    /// Code to run to reset a screen when it is entered.
    virtual void on_entered() {}

    /// Refresh all element positions.
    ///
    /// This recomputes the position of each element after the screen
    /// has been resized and before ticking/rendering.
    void refresh(Size screen_size);

    /// Render this screen.
    ///
    /// The default renderer renders all UI elements that are part of
    /// this screen.
    virtual void render(Renderer& r);

    /// Tick this screen.
    ///
    /// The default tick handler visits all elements and performs UI
    /// interactions on them; thus, calling this handler is recommended
    /// if you override it.
    virtual void tick(InputSystem& input);
};

class pr::client::Label : public Element {
    // TODO: Reflow text.
    ShapedText text;
    Position pos{};

public:
    explicit Label(ShapedText text, Position pos) : text(std::move(text)), pos(pos) {}
    explicit Label(Position pos) : pos(pos) {}

    void draw(Renderer& r) override;
    void update_text(ShapedText new_text) { text = std::move(new_text); }
};

class pr::client::TextBox : public Element {
protected:
    ShapedText label;
    Position pos{};
    Size sz{};
    i32 padding{};
    i32 min_wd{};
    i32 min_ht{};
    i32 cursor_offs = -1; // Cursor offset from the start of the text; -1 to disable.

    explicit TextBox(ShapedText label, Position pos, i32 padding, i32 min_wd = 0, i32 min_ht = 0);

    void UpdateText(ShapedText new_text);
    auto TextPos(Renderer& r) -> xy;

public:
    void draw(Renderer& r) override;
    void refresh(Size screen_size) override;
};

class pr::client::Button : public TextBox {
public:
    std::function<void()> on_click{};

    explicit Button(ShapedText label, Position pos, i32 padding, i32 min_wd = 0, i32 min_ht = 0)
        : TextBox(std::move(label), pos, padding, min_wd, min_ht) {}

    void event_click(InputSystem&) override {
        if (on_click) on_click();
    }

    void draw(Renderer& r) override;
};

class pr::client::TextEdit : public TextBox {
    struct Selection {
        i32 start;
        i32 end;
    };

    std::u32string text = U"localhost"; // FIXME: For testing. Remove.
    std::vector<ShapedText::Cluster> clusters;
    FontSize size;
    bool dirty = true;
    i32 cursor = 0;
    u32 no_blink_ticks = 0; // Used to inhibit blinking during typing.
    Selection sel{};

public:
    TextEdit(Position pos, FontSize size, i32 padding, i32 min_wd = 0, i32 min_ht = 0)
        : TextBox(ShapedText(), pos, padding, min_wd, min_ht), size{size} {
        selectable = true;
    }

    void draw(Renderer& r) override;
    void event_click(InputSystem& input) override;
    void event_input(InputSystem& input) override;
    auto value() -> std::string { return text::ToUTF8(text); }
};

class pr::client::Throbber : public Element {
    static constexpr f32 R = 20; // Radius of the throbber.

    VertexArrays vao;
    Position pos;
    bool show = true;

public:
    Throbber(Position pos);

    void draw(Renderer& r) override;
};

class pr::client::Card : public Element {
public:
    enum Scale : u8 {
        OtherPlayer,
        Field,
        Large,
        NumScales
    };

private:
    static constexpr Size CardSize[NumScales] = {Size{60, 90}, Size{120, 180}, Size{240, 360}};
    static constexpr u16 Offset[NumScales] = {1, 2, 4};

    ShapedText code[NumScales];
    ShapedText name[NumScales];
    ShapedText middle[NumScales];
    ShapedText special[NumScales];
    Position pos;
    Scale s;
    u8 count;

public:
    Card(
        Renderer& r,
        Position pos,
        std::string_view code,
        std::string_view name,
        std::string_view middle,
        std::string_view special,
        u8 count
    );

    void draw(Renderer& r) override;
    void set_scale(Scale _s);
};

template <>
struct std::formatter<pr::client::xy> : std::formatter<std::string> {
    template <typename FormatContext>
    auto format(pr::client::xy p, FormatContext& ctx) const {
        return std::formatter<std::string>::format(std::format("({}, {})", p.x, p.y), ctx);
    }
};
