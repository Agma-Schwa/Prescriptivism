module;
#include <base/Macros.hh>
#include <memory>
export module pr.client;

import pr.utils;
import pr.client.ui;
import pr.client.render;
import pr.client.render.gl;
import pr.tcp;

export namespace pr::client {
class Client;
}

namespace pr::client {
class Text;
class MenuScreen;
class ErrorScreen;
class ConnexionScreen;
}

/// Main menu of the game.
class pr::client::MenuScreen : public Screen {
public:
    MenuScreen(Client& c);
};

/// Screen that displays an error.
class pr::client::ErrorScreen : public Screen {
    /// The screen to return to after this one is closed.
    Screen* return_to;

public:
    ErrorScreen(Client& c, std::string_view message, Screen* return_to);
};

/// Screen that is displayed while we connect to a server.
///
/// This screen has all the connexion logic.
class pr::client::ConnexionScreen : public Screen {
    enum class State {
        Entered,    ///< The screen has just been entered.
        Connecting, ///< We are trying to connect in a separate thread.
        Aborted,    ///< The 'Cancel' button was pressed.
    };

    Client& client;
    State st;

public:
    ConnexionScreen(Client& c);

    void enter() override;
    void tick(InputSystem& input) override;
};

class pr::client::Client {
    LIBBASE_IMMOVABLE(Client);

public:
    /// The main renderer.
    Renderer renderer;

    /// The user input handler.
    InputSystem input_system{renderer};

    /// Screens.
    std::unique_ptr<MenuScreen> menu_screen;
    std::unique_ptr<ErrorScreen> connexion_error_screen;
    std::unique_ptr<ConnexionScreen> connexion_screen;

private:
    Screen* current_screen;

    /// TCP Connexion to the server.
    std::optional<net::TCPConnexion> server_connexion;

public:
    /// Create a new client.
    explicit Client();

    /// Connect to the server.
    void connect_to_server(std::string_view ip_address);

    /// Enter a screen.
    void enter_screen(Screen& s);

    /// Run the client for ever.
    void run();
};
