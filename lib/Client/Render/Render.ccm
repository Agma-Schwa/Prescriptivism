module;
#include <base/Macros.hh>
#include <memory>
#include <glm/glm.hpp>
export module pr.client.render;
import pr.utils;

export namespace pr::client {
struct Colour;
struct Size;

class Renderer;
}

struct pr::client::Colour {
    u8 r;
    u8 g;
    u8 b;
    u8 a;

    /// Create a new colour.
    constexpr Colour(u8 r, u8 g, u8 b, u8 a = 255) : r(r), g(g), b(b), a(a) {}
    constexpr static auto ABGR(u32 abgr) -> Colour {
        if constexpr (std::endian::native == std::endian::big)
            abgr = std::byteswap(abgr);

        return {
            u8(abgr & 0xFF),
            u8(abgr >> 8 & 0xFF),
            u8(abgr >> 16 & 0xFF),
            u8(abgr >> 24 & 0xFF),
        };
    }

    f32 red() const { return r / 255.0f; }
    f32 green() const { return g / 255.0f; }
    f32 blue() const { return b / 255.0f; }
    f32 alpha() const { return a / 255.0f; }
    auto vec4() const -> glm::vec4 { return {red(), green(), blue(), alpha()}; }

    static constinit const Colour White;
};

constexpr pr::client::Colour pr::client::Colour::White = {255, 255, 255, 255};

/// A renderer that renders to a window.
class pr::client::Renderer {
    LIBBASE_DECLARE_HIDDEN_IMPL(Renderer);

public:
    class Frame {
        LIBBASE_IMMOVABLE(Frame);
        Renderer& r;
        friend Renderer;
        explicit Frame(Renderer& r);
    public:
        ~Frame();
    };

    static auto Create(int initial_wd, int initial_ht) -> Renderer;

    /// Clear the screen.
    void clear(Colour c = Colour::White);

    /// Draw text at a position.
    void draw_text(std::string_view text, int x, int y, u32 font_size, Colour c = Colour::White);

    /// Start a new frame.
    auto frame() -> Frame;
};

template <typename T, std::size_t n>
struct std::formatter<glm::vec<n, T>> : std::formatter<std::string_view> {
    template <typename FormatContext>
    auto format(glm::vec<n, T> vec, FormatContext& ctx) const {
        std::string s{"("};
        s += std::to_string(vec.x);
        if constexpr (n >= 2) s += std::format(", {}", vec.y);
        if constexpr (n >= 3) s += std::format(", {}", vec.z);
        if constexpr (n >= 4) s += std::format(", {}", vec.w);
        s += ")";
        return std::formatter<std::string_view>::format(s, ctx);
    }
};
